/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ZolaPublishPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  obsidianPostsPath: "/posts",
  zolaProjectPath: "",
  syncStrategy: "two-way",
  githubRepoUrl: "",
  defaultBranch: "main",
  cloudflareDeployUrl: "",
  obsidianImagesPath: "/images/posts/",
  zolaImagesPath: "/static/images/"
};

// src/settingTab.ts
var import_obsidian = require("obsidian");
var ZolaPublishSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  /**
   * Open folder picker dialog
   */
  async pickFolder() {
    if (!import_obsidian.Platform.isDesktop) {
      return null;
    }
    try {
      const { dialog } = require("@electron/remote");
      const result = await dialog.showOpenDialog({
        properties: ["openDirectory"]
      });
      if (!result.canceled && result.filePaths.length > 0) {
        return result.filePaths[0];
      }
    } catch (error) {
      console.error("Failed to open folder picker:", error);
    }
    return null;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Basic Settings" });
    new import_obsidian.Setting(containerEl).setName("Obsidian Posts Path").setDesc("Path to posts directory in your vault (e.g., /posts)").addText((text) => text.setPlaceholder("/posts").setValue(this.plugin.settings.obsidianPostsPath).onChange(async (value) => {
      this.plugin.settings.obsidianPostsPath = value;
      await this.plugin.saveSettings();
    })).addButton((button) => button.setButtonText("Browse").setTooltip("Select folder").onClick(async () => {
      const folder = await this.pickFolder();
      if (folder) {
        this.plugin.settings.obsidianPostsPath = folder;
        await this.plugin.saveSettings();
        this.display();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Zola Project Path").setDesc("Path to Zola posts directory (/content/posts/)").addText((text) => text.setPlaceholder("/Users/username/zola-blog/content/posts").setValue(this.plugin.settings.zolaProjectPath).onChange(async (value) => {
      this.plugin.settings.zolaProjectPath = value;
      await this.plugin.saveSettings();
    })).addButton((button) => button.setButtonText("Browse").setTooltip("Select folder").onClick(async () => {
      const folder = await this.pickFolder();
      if (folder) {
        this.plugin.settings.zolaProjectPath = folder;
        await this.plugin.saveSettings();
        this.display();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Strategy").setDesc("Choose one-way or two-way sync").addDropdown((dropdown) => dropdown.addOption("one-way", "One-way (Obsidian \u2192 Zola)").addOption("two-way", "Two-way (Obsidian \u2194 Zola)").setValue(this.plugin.settings.syncStrategy).onChange(async (value) => {
      this.plugin.settings.syncStrategy = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("GitHub Repository URL").setDesc("Your Zola blog repository (e.g., github.com:username/blog)").addText((text) => text.setPlaceholder("github.com:username/zolablog").setValue(this.plugin.settings.githubRepoUrl).onChange(async (value) => {
      this.plugin.settings.githubRepoUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default Branch").setDesc("Git branch name (e.g., main)").addText((text) => text.setPlaceholder("main").setValue(this.plugin.settings.defaultBranch).onChange(async (value) => {
      this.plugin.settings.defaultBranch = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Cloudflare Deploy URL (Optional)").setDesc("Link to deployment dashboard for quick access").addText((text) => text.setPlaceholder("https://dash.cloudflare.com/...").setValue(this.plugin.settings.cloudflareDeployUrl).onChange(async (value) => {
      this.plugin.settings.cloudflareDeployUrl = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "Image Management" });
    new import_obsidian.Setting(containerEl).setName("Obsidian Images Path").setDesc("Local image directory in your vault (default: /images/posts/)").addText((text) => text.setPlaceholder("/images/posts/").setValue(this.plugin.settings.obsidianImagesPath).onChange(async (value) => {
      this.plugin.settings.obsidianImagesPath = value;
      await this.plugin.saveSettings();
    })).addButton((button) => button.setButtonText("Browse").setTooltip("Select folder").onClick(async () => {
      const folder = await this.pickFolder();
      if (folder) {
        this.plugin.settings.obsidianImagesPath = folder;
        await this.plugin.saveSettings();
        this.display();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Zola Images Path").setDesc("Zola static images directory (default: /static/images/)").addText((text) => text.setPlaceholder("/Users/username/zola-blog/static/images").setValue(this.plugin.settings.zolaImagesPath).onChange(async (value) => {
      this.plugin.settings.zolaImagesPath = value;
      await this.plugin.saveSettings();
    })).addButton((button) => button.setButtonText("Browse").setTooltip("Select folder").onClick(async () => {
      const folder = await this.pickFolder();
      if (folder) {
        this.plugin.settings.zolaImagesPath = folder;
        await this.plugin.saveSettings();
        this.display();
      }
    }));
    containerEl.createEl("p", {
      text: "Local sync only (Vault \u2194 Zola). The plugin ensures images referenced in articles are consistent between both directories.",
      cls: "setting-item-description"
    });
  }
};

// src/view.ts
var import_obsidian3 = require("obsidian");

// src/articleManager.ts
var import_obsidian2 = require("obsidian");
var ArticleManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  /**
   * Get all articles list
   */
  async getArticles() {
    const articles = [];
    const obsidianPostsPath = this.plugin.settings.obsidianPostsPath;
    const adapter = this.app.vault.adapter;
    const vaultBasePath = adapter.getBasePath();
    let basePath;
    if (obsidianPostsPath.startsWith(vaultBasePath)) {
      basePath = obsidianPostsPath.substring(vaultBasePath.length + 1);
    } else if (obsidianPostsPath.startsWith("/")) {
      basePath = obsidianPostsPath.replace(/^\//, "");
    } else {
      basePath = obsidianPostsPath;
    }
    basePath = basePath.replace(/\\/g, "/");
    const folder = this.app.vault.getAbstractFileByPath(basePath);
    if (!folder || !(folder instanceof import_obsidian2.TFolder)) {
      return articles;
    }
    const files = this.app.vault.getMarkdownFiles().filter(
      (file) => file.path.startsWith(basePath)
    );
    for (const file of files) {
      const info = await this.parseArticle(file);
      if (info) {
        articles.push(info);
      }
    }
    articles.sort((a, b) => b.date.localeCompare(a.date));
    return articles;
  }
  /**
   * Parse article metadata
   */
  async parseArticle(file) {
    try {
      const content = await this.app.vault.read(file);
      const frontmatter = this.parseFrontmatter(content);
      if (!frontmatter) {
        return null;
      }
      return {
        file,
        title: frontmatter.title || file.basename,
        date: frontmatter.date || "",
        tags: frontmatter.tags || [],
        draft: frontmatter.draft === true
      };
    } catch (error) {
      console.error("Failed to parse article:", file.path, error);
      return null;
    }
  }
  /**
   * Parse TOML Frontmatter
   */
  parseFrontmatter(content) {
    const match = content.match(/^\+\+\+\n([\s\S]*?)\n\+\+\+/);
    if (!match) {
      return null;
    }
    const toml = match[1];
    const result = {};
    const lines = toml.split("\n");
    let currentSection = "";
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#")) {
        continue;
      }
      if (trimmed.startsWith("[")) {
        const sectionMatch = trimmed.match(/\[(\w+)\]/);
        if (sectionMatch) {
          currentSection = sectionMatch[1];
          if (!result[currentSection]) {
            result[currentSection] = {};
          }
        }
        continue;
      }
      const kvMatch = trimmed.match(/^(\w+)\s*=\s*(.+)$/);
      if (kvMatch) {
        const key = kvMatch[1];
        let value = kvMatch[2].trim();
        if (value === "true") {
          value = true;
        } else if (value === "false") {
          value = false;
        } else if (value.startsWith('"') && value.endsWith('"')) {
          value = value.slice(1, -1);
        } else if (value.startsWith("[") && value.endsWith("]")) {
          const arrayContent = value.slice(1, -1);
          value = arrayContent.split(",").map((item) => item.trim().replace(/^"(.*)"$/, "$1")).filter((item) => item);
        }
        if (currentSection) {
          result[currentSection][key] = value;
        } else {
          result[key] = value;
        }
      }
    }
    if (result.taxonomies && result.taxonomies.tags) {
      result.tags = result.taxonomies.tags;
    }
    return result;
  }
  /**
   * Get all tags and their article counts
   */
  async getAllTags() {
    const articles = await this.getArticles();
    const tagMap = /* @__PURE__ */ new Map();
    for (const article of articles) {
      for (const tag of article.tags) {
        tagMap.set(tag, (tagMap.get(tag) || 0) + 1);
      }
    }
    return tagMap;
  }
  /**
   * Filter articles by tag
   */
  async getArticlesByTag(tag) {
    const articles = await this.getArticles();
    return articles.filter((article) => article.tags.includes(tag));
  }
};

// src/view.ts
var fs = __toESM(require("fs"));
var VIEW_TYPE_ZOLAPUBLISH = "zolapublish-view";
var ZolaPublishView = class extends import_obsidian3.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.expandedTags = /* @__PURE__ */ new Set();
    this.expandedLogs = /* @__PURE__ */ new Set();
    this.currentTab = "tags";
    this.plugin = plugin;
    this.articleManager = new ArticleManager(this.app, plugin);
    this.registerEvent(
      this.app.vault.on("modify", () => this.refresh())
    );
    this.registerEvent(
      this.app.vault.on("create", () => this.refresh())
    );
    this.registerEvent(
      this.app.vault.on("delete", () => this.refresh())
    );
  }
  getViewType() {
    return VIEW_TYPE_ZOLAPUBLISH;
  }
  getDisplayText() {
    return "Zolapublish";
  }
  getIcon() {
    return "pencil";
  }
  async onOpen() {
    this.render();
  }
  async onClose() {
  }
  async render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("zolapublish-view");
    const topHeader = container.createDiv({ cls: "zolapublish-top-header" });
    const manageTitle = topHeader.createEl("h3", {
      text: "Zolapublish",
      cls: "zolapublish-manage-title"
    });
    const logIcon = topHeader.createEl("span", { cls: "zolapublish-log-icon" });
    (0, import_obsidian3.setIcon)(logIcon, "scroll-text");
    logIcon.onclick = () => {
      this.currentTab = this.currentTab === "logs" ? "tags" : "logs";
      this.render();
    };
    this.createActionBar(container);
    await this.createSyncStatus(container);
    this.createSectionTitle(container);
    if (this.currentTab === "logs") {
      this.renderLogsSection(container);
    } else {
      await this.renderTagsSection(container);
    }
  }
  createActionBar(container) {
    const actionBar = container.createDiv({ cls: "zolapublish-action-bar" });
    const actions = [
      {
        icon: "file-plus",
        title: "New Article",
        action: async () => {
          await this.plugin.createNewArticle();
          this.refresh();
        }
      },
      {
        icon: "refresh-cw",
        title: "Synchronize",
        action: async () => {
          await this.plugin.syncArticles("push");
        }
      },
      {
        icon: "download-cloud",
        title: "Pull from Zola",
        action: async () => {
          await this.plugin.syncArticles("pull");
        }
      },
      {
        icon: "eye",
        title: "Launch Preview",
        action: async () => {
          await this.plugin.launchPreview();
        }
      },
      {
        icon: "upload-cloud",
        title: "Publish to GitHub",
        action: async () => {
          await this.plugin.publishToGitHub();
        }
      }
    ];
    actions.forEach(({ icon: iconName, title, action }) => {
      const btn = actionBar.createEl("button", {
        cls: "zolapublish-icon-btn",
        attr: { "aria-label": title }
      });
      (0, import_obsidian3.setIcon)(btn, iconName);
      btn.onclick = action;
    });
  }
  async createSyncStatus(container) {
    const statusDiv = container.createDiv({ cls: "zolapublish-sync-status" });
    try {
      const { obsidianPostsPath, zolaProjectPath, obsidianImagesPath, zolaImagesPath } = this.plugin.settings;
      if (!zolaProjectPath) {
        statusDiv.createSpan({ text: "Configure Zola path in settings", cls: "zolapublish-status-warning" });
        return;
      }
      const adapter = this.app.vault.adapter;
      const vaultBasePath = adapter.getBasePath();
      let basePath;
      if (obsidianPostsPath.startsWith(vaultBasePath)) {
        basePath = obsidianPostsPath.substring(vaultBasePath.length + 1);
      } else if (obsidianPostsPath.startsWith("/")) {
        basePath = obsidianPostsPath.replace(/^\//, "");
      } else {
        basePath = obsidianPostsPath;
      }
      basePath = basePath.replace(/\\/g, "/");
      const vaultArticles = this.app.vault.getMarkdownFiles().filter((file) => {
        if (!file.path.startsWith(basePath))
          return false;
        if (file.name === "_index.md" || file.name === "index.md")
          return false;
        return true;
      });
      let zolaArticles = 0;
      if (fs.existsSync(zolaProjectPath)) {
        const zolaFiles = fs.readdirSync(zolaProjectPath);
        zolaArticles = zolaFiles.filter((f) => {
          if (!f.endsWith(".md"))
            return false;
          if (f === "_index.md" || f === "index.md")
            return false;
          return true;
        }).length;
      }
      let vaultImages = 0;
      let zolaImages = 0;
      if (obsidianImagesPath && zolaImagesPath) {
        const imageExtensions = [".png", ".jpg", ".jpeg", ".gif", ".webp", ".svg", ".ico"];
        const obsidianImageDir = obsidianImagesPath.replace(/^\//, "");
        const allFiles = this.app.vault.getFiles();
        vaultImages = allFiles.filter(
          (file) => file.path.startsWith(obsidianImageDir) && imageExtensions.some((ext) => file.path.toLowerCase().endsWith(ext))
        ).length;
        if (fs.existsSync(zolaImagesPath)) {
          const zolaImageFiles = fs.readdirSync(zolaImagesPath);
          zolaImages = zolaImageFiles.filter(
            (f) => imageExtensions.some((ext) => f.toLowerCase().endsWith(ext))
          ).length;
        }
      }
      const articleDiff = vaultArticles.length - zolaArticles;
      const imageDiff = vaultImages - zolaImages;
      const parts = [];
      if (articleDiff > 0) {
        parts.push(`${articleDiff} article${articleDiff > 1 ? "s" : ""}`);
      }
      if (imageDiff > 0) {
        parts.push(`${imageDiff} image${imageDiff > 1 ? "s" : ""}`);
      }
      if (parts.length > 0) {
        const statusText = parts.join(", ") + " waiting to sync";
        statusDiv.createSpan({ text: statusText, cls: "zolapublish-status-pending" });
        const syncIcon = statusDiv.createSpan({ cls: "zolapublish-status-icon" });
        (0, import_obsidian3.setIcon)(syncIcon, "alert-circle");
      } else {
        statusDiv.createSpan({ text: "All synced", cls: "zolapublish-status-synced" });
        const checkIcon = statusDiv.createSpan({ cls: "zolapublish-status-icon" });
        (0, import_obsidian3.setIcon)(checkIcon, "check-circle");
      }
    } catch (error) {
      console.error("Failed to calculate sync status:", error);
      statusDiv.createSpan({ text: "Status unavailable", cls: "zolapublish-status-error" });
    }
  }
  createSectionTitle(container) {
    const title = container.createEl("h3", {
      text: "Tags List",
      cls: "zolapublish-section-title"
    });
    title.onclick = () => {
      this.currentTab = "tags";
      this.render();
    };
  }
  renderLogsSection(container) {
    const logsSection = container.createDiv({ cls: "zolapublish-logs-section" });
    const logsList = logsSection.createDiv({ cls: "zolapublish-logs-list" });
    const logs = this.plugin.logManager.getFormattedLogs();
    if (logs.length === 0) {
      logsList.createEl("div", {
        text: "No logs yet.",
        cls: "zolapublish-empty-state"
      });
      return;
    }
    logs.forEach((log, index) => {
      const logItem = logsList.createDiv({ cls: "zolapublish-log-item" });
      const logHeader = logItem.createDiv({ cls: "zolapublish-log-header" });
      const logTimeRow = logHeader.createDiv({ cls: "zolapublish-log-time-row" });
      logTimeRow.createSpan({ text: log.timestamp, cls: "zolapublish-log-timestamp" });
      const expandIcon = logTimeRow.createSpan({ cls: "zolapublish-log-expand-icon" });
      expandIcon.textContent = this.expandedLogs.has(index) ? "\u2212" : "+";
      logHeader.createDiv({ text: log.summary, cls: "zolapublish-log-summary" });
      logHeader.onclick = () => {
        if (this.expandedLogs.has(index)) {
          this.expandedLogs.delete(index);
        } else {
          this.expandedLogs.add(index);
        }
        this.render();
      };
      if (this.expandedLogs.has(index) && log.details && log.details.length > 0) {
        const logDetails = logItem.createDiv({ cls: "zolapublish-log-details" });
        log.details.forEach((detail) => {
          logDetails.createDiv({ text: `\u2022 ${detail}` });
        });
      }
    });
  }
  async renderTagsSection(container) {
    const tagsSection = container.createDiv({ cls: "zolapublish-tags-section" });
    const tagsList = tagsSection.createDiv({ cls: "zolapublish-tags-list" });
    try {
      const tagsMap = await this.articleManager.getAllTags();
      if (tagsMap.size === 0) {
        tagsList.createEl("div", {
          text: "No tags found.",
          cls: "zolapublish-empty-state"
        });
        return;
      }
      const sortedTags = Array.from(tagsMap.entries()).sort((a, b) => b[1] - a[1]);
      for (const [tagName, count] of sortedTags) {
        const tagItem = tagsList.createDiv({ cls: "zolapublish-tag-item" });
        const tagHeader = tagItem.createDiv({ cls: "zolapublish-tag-header" });
        const tagNameEl = tagHeader.createDiv({ cls: "zolapublish-tag-name-wrapper" });
        tagNameEl.createSpan({ text: `# ${tagName}`, cls: "zolapublish-tag-name" });
        tagHeader.createSpan({ text: `${count}`, cls: "zolapublish-tag-count" });
        const expandIcon = tagHeader.createSpan({ cls: "zolapublish-tag-expand-icon" });
        expandIcon.textContent = this.expandedTags.has(tagName) ? "\u2212" : "+";
        tagHeader.onclick = () => {
          if (this.expandedTags.has(tagName)) {
            this.expandedTags.delete(tagName);
          } else {
            this.expandedTags.add(tagName);
          }
          this.render();
        };
        if (this.expandedTags.has(tagName)) {
          const articlesContainer = tagItem.createDiv({ cls: "zolapublish-tag-articles" });
          await this.renderTagArticles(articlesContainer, tagName);
        }
      }
    } catch (error) {
      console.error("Failed to load tags:", error);
      tagsList.createEl("div", {
        text: "Failed to load tags.",
        cls: "zolapublish-error-state"
      });
    }
  }
  async renderTagArticles(container, tagName) {
    try {
      const articles = await this.articleManager.getArticlesByTag(tagName);
      if (articles.length === 0) {
        container.createEl("div", {
          text: "No articles found.",
          cls: "zolapublish-empty-state"
        });
        return;
      }
      articles.forEach((article) => {
        const articleItem = container.createDiv({ cls: "zolapublish-tag-article-item" });
        articleItem.createSpan({ text: article.title, cls: "zolapublish-tag-article-title" });
        articleItem.createSpan({ text: article.date, cls: "zolapublish-tag-article-date" });
        if (article.draft) {
          articleItem.createSpan({ text: "Draft", cls: "zolapublish-draft-badge-small" });
        }
        articleItem.onclick = async () => {
          const leaf = this.app.workspace.getLeaf(false);
          await leaf.openFile(article.file);
        };
      });
    } catch (error) {
      console.error("Failed to load tag articles:", error);
    }
  }
  refresh() {
    this.render();
  }
};

// src/syncManager.ts
var import_obsidian4 = require("obsidian");
var fs2 = __toESM(require("fs"));
var path = __toESM(require("path"));
var SyncManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  /**
   * Sync articles to Zola project
   */
  async pushToZola() {
    var _a;
    const { obsidianPostsPath, zolaProjectPath } = this.plugin.settings;
    if (!zolaProjectPath) {
      new import_obsidian4.Notice("Please configure Zola project path in settings first");
      return;
    }
    try {
      new import_obsidian4.Notice("Pushing articles to Zola project...");
      const adapter = this.app.vault.adapter;
      const vaultBasePath = adapter.getBasePath();
      let basePath;
      if (obsidianPostsPath.startsWith(vaultBasePath)) {
        basePath = obsidianPostsPath.substring(vaultBasePath.length + 1);
      } else if (obsidianPostsPath.startsWith("/")) {
        basePath = obsidianPostsPath.replace(/^\//, "");
      } else {
        basePath = obsidianPostsPath;
      }
      basePath = basePath.replace(/\\/g, "/");
      const systemFiles = ["_index.md", "index.md"];
      const files = this.app.vault.getMarkdownFiles().filter((file) => {
        if (!file.path.startsWith(basePath)) {
          return false;
        }
        if (systemFiles.includes(file.name)) {
          return false;
        }
        return true;
      });
      let syncCount = 0;
      let errorCount = 0;
      for (const file of files) {
        try {
          await this.syncFileToZola(file);
          syncCount++;
        } catch (error) {
          console.error(`Failed to sync file: ${file.path}`, error);
          errorCount++;
        }
      }
      await this.syncImages();
      new import_obsidian4.Notice(`Push complete! Success: ${syncCount}, Failed: ${errorCount}`);
      await ((_a = this.plugin.logManager) == null ? void 0 : _a.addLog({
        action: "sync-push",
        summary: `Pushed ${syncCount} articles to Zola`,
        details: files.map((f) => `Pushed: ${f.basename}`)
      }));
    } catch (error) {
      console.error("Push failed:", error);
      new import_obsidian4.Notice("Push failed, please check console");
    }
  }
  /**
   * Pull articles from Zola project
   */
  async pullFromZola() {
    var _a;
    const { obsidianPostsPath, zolaProjectPath, syncStrategy } = this.plugin.settings;
    if (!zolaProjectPath) {
      new import_obsidian4.Notice("Please configure Zola project path in settings first");
      return;
    }
    if (syncStrategy !== "two-way") {
      new import_obsidian4.Notice("Current setting is one-way sync, cannot pull");
      return;
    }
    try {
      new import_obsidian4.Notice("Pulling articles from Zola project...");
      const adapter = this.app.vault.adapter;
      if (!fs2.existsSync(zolaProjectPath)) {
        new import_obsidian4.Notice("Zola project path does not exist");
        return;
      }
      const zolaFiles = this.getZolaFiles(zolaProjectPath);
      let syncCount = 0;
      let errorCount = 0;
      for (const zolaFile of zolaFiles) {
        try {
          await this.syncFileFromZola(zolaFile);
          syncCount++;
        } catch (error) {
          console.error(`Failed to pull file: ${zolaFile}`, error);
          errorCount++;
        }
      }
      await this.syncImages();
      new import_obsidian4.Notice(`Pull complete! Success: ${syncCount}, Failed: ${errorCount}`);
      await ((_a = this.plugin.logManager) == null ? void 0 : _a.addLog({
        action: "sync-pull",
        summary: `Pulled ${syncCount} articles from Zola`,
        details: zolaFiles.map((f) => `Pulled: ${path.basename(f)}`)
      }));
    } catch (error) {
      console.error("Pull failed:", error);
      new import_obsidian4.Notice("Pull failed, please check console");
    }
  }
  /**
   * Sync single file to Zola
   */
  async syncFileToZola(file) {
    const zolaProjectPath = this.plugin.settings.zolaProjectPath;
    let content = await this.app.vault.read(file);
    const fileName = file.name;
    content = this.convertImageLinks(content);
    const targetPath = path.join(zolaProjectPath, fileName);
    if (fs2.existsSync(targetPath)) {
      const existingContent = fs2.readFileSync(targetPath, "utf-8");
      if (existingContent === content) {
        return;
      }
    }
    fs2.writeFileSync(targetPath, content, "utf-8");
  }
  /**
   * Convert image links: Obsidian format -> Zola format
   * ![[../post_imgs/Mapper.png]] -> ![](/post_imgs/Mapper.png)
   */
  convertImageLinks(content) {
    const obsidianImageRegex = /!\[\[([^\]]+)\]\]/g;
    const converted = content.replace(obsidianImageRegex, (match, imagePath) => {
      let cleanPath = imagePath.replace(/^\.\.\//, "").replace(/^\.\//, "");
      if (!cleanPath.startsWith("/")) {
        cleanPath = "/" + cleanPath;
      }
      return `![](${cleanPath})`;
    });
    return converted;
  }
  /**
   * Sync single file from Zola
   */
  async syncFileFromZola(zolaFilePath) {
    const obsidianPostsPath = this.plugin.settings.obsidianPostsPath;
    let content = fs2.readFileSync(zolaFilePath, "utf-8");
    content = this.convertImageLinksToObsidian(content);
    const fileName = path.basename(zolaFilePath);
    const adapter = this.app.vault.adapter;
    const vaultBasePath = adapter.getBasePath();
    const fullTargetPath = path.join(obsidianPostsPath, fileName);
    let relativePath = fullTargetPath;
    if (fullTargetPath.startsWith(vaultBasePath)) {
      relativePath = path.relative(vaultBasePath, fullTargetPath);
    } else if (obsidianPostsPath.startsWith("/")) {
      relativePath = obsidianPostsPath.replace(/^\//, "") + "/" + fileName;
    } else {
      relativePath = obsidianPostsPath + "/" + fileName;
    }
    const targetPath = relativePath.replace(/\\/g, "/");
    const existingFile = this.app.vault.getAbstractFileByPath(targetPath);
    if (existingFile instanceof import_obsidian4.TFile) {
      await this.app.vault.modify(existingFile, content);
    } else {
      await this.app.vault.create(targetPath, content);
    }
  }
  /**
   * Convert image links: Zola format -> Obsidian format
   * ![](/post_imgs/Mapper.png) -> ![[../post_imgs/Mapper.png]]
   */
  convertImageLinksToObsidian(content) {
    const markdownImageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
    const converted = content.replace(markdownImageRegex, (match, altText, imagePath) => {
      if (imagePath.startsWith("/")) {
        const obsidianPath = "../" + imagePath.substring(1);
        return `![[${obsidianPath}]]`;
      }
      return match;
    });
    return converted;
  }
  /**
   * Get all markdown files in Zola directory
   */
  getZolaFiles(zolaPath) {
    const files = [];
    if (!fs2.existsSync(zolaPath)) {
      return files;
    }
    const entries = fs2.readdirSync(zolaPath);
    const systemFiles = ["_index.md", "index.md", "_index", "index"];
    for (const entry of entries) {
      const entryLower = entry.toLowerCase();
      if (entry.startsWith(".")) {
        continue;
      }
      if (systemFiles.some((sf) => entryLower === sf || entryLower === sf + ".md")) {
        continue;
      }
      const fullPath = path.join(zolaPath, entry);
      const stat = fs2.statSync(fullPath);
      if (stat.isFile() && entry.endsWith(".md")) {
        files.push(fullPath);
      }
    }
    return files;
  }
  /**
   * Sync image files (only push images that exist in Obsidian but not in Zola)
   */
  async syncImages() {
    const { obsidianImagesPath, zolaImagesPath } = this.plugin.settings;
    if (!zolaImagesPath || !obsidianImagesPath) {
      return;
    }
    try {
      const adapter = this.app.vault.adapter;
      let obsidianImageDir;
      if (obsidianImagesPath.startsWith("/")) {
        const pathParts = obsidianImagesPath.split("/");
        let vaultRootIndex = -1;
        for (let i = 0; i < pathParts.length - 1; i++) {
          const part = pathParts[i];
          if (part.includes(" ") || part.includes("Brain") || part.includes("Vault") || part.includes("Obsidian")) {
            vaultRootIndex = i;
            break;
          }
        }
        if (vaultRootIndex !== -1 && vaultRootIndex < pathParts.length - 1) {
          const relativeParts = pathParts.slice(vaultRootIndex + 1);
          obsidianImageDir = relativeParts.join("/");
        } else {
          obsidianImageDir = obsidianImagesPath.replace(/^\//, "");
        }
      } else {
        obsidianImageDir = obsidianImagesPath;
      }
      const imageExtensions = [".png", ".jpg", ".jpeg", ".gif", ".webp", ".svg", ".ico"];
      const allFiles = this.app.vault.getFiles();
      const imageFiles = allFiles.filter(
        (file) => file.path.startsWith(obsidianImageDir) && imageExtensions.some((ext) => file.path.toLowerCase().endsWith(ext))
      );
      if (imageFiles.length === 0) {
        return;
      }
      if (!fs2.existsSync(zolaImagesPath)) {
        fs2.mkdirSync(zolaImagesPath, { recursive: true });
      }
      let syncedCount = 0;
      let skippedCount = 0;
      for (const imageFile of imageFiles) {
        try {
          const fileName = imageFile.name;
          const targetPath = path.join(zolaImagesPath, fileName);
          if (fs2.existsSync(targetPath)) {
            skippedCount++;
            continue;
          }
          const content = await adapter.readBinary(imageFile.path);
          fs2.writeFileSync(targetPath, Buffer.from(content));
          syncedCount++;
        } catch (error) {
          console.error(`Failed to sync image: ${imageFile.name}`, error);
        }
      }
      if (syncedCount > 0) {
        new import_obsidian4.Notice(`Synced ${syncedCount} new images`);
      }
    } catch (error) {
      console.error("Image sync failed:", error);
      new import_obsidian4.Notice("Error syncing images, please check console");
    }
  }
};

// src/logManager.ts
var LogManager = class {
  constructor(app, plugin) {
    this.logs = [];
    this.app = app;
    this.plugin = plugin;
    this.loadLogs();
  }
  /**
   * Add log entry
   */
  async addLog(log) {
    const entry = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      ...log
    };
    this.logs.unshift(entry);
    if (this.logs.length > 100) {
      this.logs = this.logs.slice(0, 100);
    }
    await this.saveLogs();
  }
  /**
   * Get all logs
   */
  getLogs() {
    return this.logs;
  }
  /**
   * Get formatted logs (for display)
   */
  getFormattedLogs() {
    return this.logs.map((log) => ({
      timestamp: this.formatTimestamp(log.timestamp),
      summary: log.summary,
      details: log.details
    }));
  }
  /**
   * Clear all logs
   */
  async clearLogs() {
    this.logs = [];
    await this.saveLogs();
  }
  /**
   * Format timestamp
   */
  formatTimestamp(timestamp) {
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    return `${year}-${month}-${day} ${hours}:${minutes}`;
  }
  /**
   * Save logs to data file
   */
  async saveLogs() {
    try {
      await this.plugin.saveData({
        ...this.plugin.settings,
        logs: this.logs
      });
    } catch (error) {
      console.error("Failed to save logs:", error);
    }
  }
  /**
   * Load logs
   */
  async loadLogs() {
    try {
      const data = await this.plugin.loadData();
      this.logs = (data == null ? void 0 : data.logs) || [];
    } catch (error) {
      console.error("Failed to load logs:", error);
      this.logs = [];
    }
  }
};

// main.ts
var import_child_process = require("child_process");
var import_util = require("util");
var execAsync = (0, import_util.promisify)(import_child_process.exec);
var ZolaPublishPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.zolaPreviewRunning = false;
  }
  async onload() {
    await this.loadSettings();
    this.syncManager = new SyncManager(this.app, this);
    this.logManager = new LogManager(this.app, this);
    this.registerView(
      VIEW_TYPE_ZOLAPUBLISH,
      (leaf) => new ZolaPublishView(leaf, this)
    );
    this.addRibbonIcon("pencil", "Zolapublish", (evt) => {
      this.activateView();
    });
    this.addSettingTab(new ZolaPublishSettingTab(this.app, this));
    this.registerCommands();
    this.app.workspace.onLayoutReady(() => {
      this.activateView();
    });
  }
  /**
   * Register plugin commands
   */
  registerCommands() {
    this.addCommand({
      id: "create-new-article",
      name: "Create new article",
      callback: async () => {
        await this.createNewArticle();
      }
    });
    this.addCommand({
      id: "sync-to-zola",
      name: "Synchronize to Zola",
      callback: async () => {
        await this.syncArticles("push");
      }
    });
    this.addCommand({
      id: "pull-from-zola",
      name: "Pull from Zola",
      callback: async () => {
        await this.syncArticles("pull");
      }
    });
    this.addCommand({
      id: "launch-preview",
      name: "Launch Zola preview",
      callback: async () => {
        await this.launchPreview();
      }
    });
    this.addCommand({
      id: "publish-to-github",
      name: "Publish to GitHub",
      callback: async () => {
        await this.publishToGitHub();
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_ZOLAPUBLISH);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({
          type: VIEW_TYPE_ZOLAPUBLISH,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  // ============ Core functionality methods ============
  /**
   * Create new article
   */
  async createNewArticle() {
    try {
      if (!this.settings.obsidianPostsPath) {
        new import_obsidian5.Notice("Please configure Obsidian posts path in settings first");
        return;
      }
      const now = /* @__PURE__ */ new Date();
      const dateStr = now.toISOString().split("T")[0];
      const fileName = `${dateStr}-new-article.md`;
      const vault = this.app.vault;
      const adapter = vault.adapter;
      const vaultBasePath = adapter.getBasePath();
      const obsidianPostsPath = this.settings.obsidianPostsPath;
      let basePath;
      if (obsidianPostsPath.startsWith(vaultBasePath)) {
        basePath = obsidianPostsPath.substring(vaultBasePath.length + 1);
      } else if (obsidianPostsPath.startsWith("/")) {
        basePath = obsidianPostsPath.replace(/^\//, "");
      } else {
        basePath = obsidianPostsPath;
      }
      basePath = basePath.replace(/\\/g, "/");
      const fullPath = `${basePath}/${fileName}`;
      const frontmatter = `+++
title = "New Article"
date = ${dateStr}
description = "Brief description for SEO"
authors = ["Your Name"]
draft = true

[taxonomies]
tags = []

[extra]
toc = true
+++

# New Article

Start writing here...
`;
      await vault.create(fullPath, frontmatter);
      const file = vault.getAbstractFileByPath(fullPath);
      if (file instanceof import_obsidian5.TFile) {
        const leaf = this.app.workspace.getLeaf(false);
        await leaf.openFile(file);
      }
      new import_obsidian5.Notice(`Article created: ${fileName}`);
    } catch (error) {
      console.error("Failed to create article:", error);
      new import_obsidian5.Notice("Failed to create article, please check console");
    }
  }
  /**
   * Synchronize articles
   */
  async syncArticles(direction) {
    if (direction === "push") {
      await this.syncManager.pushToZola();
    } else {
      await this.syncManager.pullFromZola();
    }
  }
  /**
   * Launch preview
   */
  async launchPreview() {
    try {
      if (!import_obsidian5.Platform.isMacOS) {
        new import_obsidian5.Notice('Preview launch is currently only supported on macOS.\nWindows/Linux support coming soon.\n\nPlease run "zola serve" manually in your terminal.');
        return;
      }
      if (!this.settings.zolaProjectPath) {
        new import_obsidian5.Notice("Please configure Zola project path in settings first");
        return;
      }
      try {
        const { stdout } = await execAsync("lsof -ti:1111");
        if (stdout.trim()) {
          new import_obsidian5.Notice("Stopping old Zola preview...");
          const pids = stdout.trim().split("\n");
          for (const pid of pids) {
            try {
              await execAsync(`kill ${pid}`);
            } catch (e) {
            }
          }
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
      } catch (error) {
      }
      new import_obsidian5.Notice("Starting Zola preview service...");
      const zolaRootPath = this.settings.zolaProjectPath.replace(/\/content\/posts\/?$/, "");
      const command = `cd "${zolaRootPath}" && zola serve`;
      await execAsync(`osascript -e 'tell application "Terminal" to do script "cd \\"${zolaRootPath}\\" && zola serve"'`);
      this.zolaPreviewRunning = true;
      new import_obsidian5.Notice("Preview service started!");
      setTimeout(() => {
        const { exec: exec2 } = require("child_process");
        exec2("open http://127.0.0.1:1111", (error) => {
          if (error) {
            console.error("Failed to open browser:", error);
            new import_obsidian5.Notice("Please visit manually: http://127.0.0.1:1111");
          } else {
            new import_obsidian5.Notice("Browser opened: http://127.0.0.1:1111");
          }
        });
      }, 3e3);
      await this.logManager.addLog({
        action: "preview",
        summary: "Launched Zola preview service",
        details: [`Run in terminal: ${command}`, "Browser address: http://127.0.0.1:1111"]
      });
    } catch (error) {
      console.error("Failed to launch preview:", error);
      new import_obsidian5.Notice("Failed to launch preview. Please ensure Zola is installed and project path is configured correctly");
      this.zolaPreviewRunning = false;
    }
  }
  /**
   * Publish to GitHub
   */
  async publishToGitHub() {
    try {
      if (!import_obsidian5.Platform.isMacOS) {
        new import_obsidian5.Notice('Auto-publish is currently optimized for macOS.\n\nFor Windows/Linux, please use git commands manually:\ngit add .\ngit commit -m "Update"\ngit push');
        return;
      }
      if (!this.settings.githubRepoUrl) {
        new import_obsidian5.Notice("Please configure GitHub repository URL in settings first");
        return;
      }
      if (!this.settings.zolaProjectPath) {
        new import_obsidian5.Notice("Please configure Zola project path in settings first");
        return;
      }
      new import_obsidian5.Notice("Publishing to GitHub...");
      const zolaRootPath = this.settings.zolaProjectPath.replace(/\/content\/posts\/?$/, "");
      const commands = [
        `cd "${zolaRootPath}"`,
        "git add .",
        `git commit -m "Update blog posts - ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}"`,
        `git push origin ${this.settings.defaultBranch}`
      ];
      const fullCommand = commands.join(" && ");
      try {
        const { stdout, stderr } = await execAsync(fullCommand);
        new import_obsidian5.Notice("Published successfully! Code pushed to GitHub");
        await this.logManager.addLog({
          action: "publish",
          summary: "Published to GitHub",
          details: [
            `Repository: ${this.settings.githubRepoUrl}`,
            `Branch: ${this.settings.defaultBranch}`,
            `Time: ${(/* @__PURE__ */ new Date()).toLocaleString()}`
          ]
        });
        if (this.settings.cloudflareDeployUrl) {
          new import_obsidian5.Notice("You can check deployment status on Cloudflare Pages");
        }
      } catch (gitError) {
        console.error("Git command execution failed:", gitError);
        if (gitError instanceof Error && gitError.message.includes("nothing to commit")) {
          new import_obsidian5.Notice("No new changes to commit");
        } else {
          throw gitError;
        }
      }
    } catch (error) {
      console.error("Publishing failed:", error);
      new import_obsidian5.Notice("Publishing failed, please check console or verify Git configuration");
    }
  }
};
